<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 2</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.13.0/dist/phaser.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
    <script type="text/javascript" src="static/scripts/Arrow.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
    namespace = '';

    var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port + namespace);

    var pendingData = []

    // I chose the pixel dimensions to be powers of two because of the 
    // tiling restrictions. 
    var w = 1024;
    var h = 1024;
    var scale = 1;
    
    var config = {
        type: Phaser.AUTO,
        width: w,
        height: h,
        backgroundColor: '#0b486b',
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);
    var seatile;
    var seasprites = [];
    var cursors;

    var vizstate = {
        x: 0,
        y: 0,
        psi: 0,
        u: 0,
        v: 0,
        r: 0
    };

    var ref = {
        x: 0,
        y: 0,
        psi: 0,
        u: 0,
        v: 0,
        r: 0
    };

    socket.on('sim_state', function(msg) {
        // console.log(msg.data)
        //data = JSON.parse(msg.data)
        
        // Make sure that the datasource has the correct values
        msg.data.forEach(point => {
            pendingData.push(point);
        });
    });

    function preload ()
    {
        this.backgroundColor = '#0072bc';
        this.load.spritesheet('seatile', 'static/assets/sea-sprite-sheet.png', { frameWidth: 128, frameHeight: 128 });
        this.load.spritesheet('seasprite', 'static/assets/sea-sprite-sheet.png', { frameWidth: 128, frameHeight: 128 });
        this.load.image('boat', 'static/assets/boat-shadow.png')
    }

    function create ()
    {
        cursors = this.input.keyboard.createCursorKeys();
        
        this.anims.create({
            key: 'shimmer',
            frames: this.anims.generateFrameNumbers('seasprite', { start: 0, end: 15 }),
            frameRate: 5,
            repeat: -1
        });

        // Create sprites that act as a tiling background and start their animations
        var n = 8;
        var tmp;
        for (var i = -2 ; i<n+2 ; i++){
            for (var j = -2 ; j < n+2 ; j++){
                tmp =  this.add.sprite((i+0.5)*w/n, (j+0.5)*h/n, w/n, h/n, 'seasprite').setScrollFactor(0.5);
                
                // Might just make the sea tile lighter, opacity can be expensive
                tmp.alpha = 0.5;

                tmp.anims.play('shimmer')

                seasprites.push(tmp);
            }
        }
        
        boat = this.physics.add.sprite(w/2, h/2, 'boat');
        this.cameras.main.startFollow(boat, true,  0.05, 0.05); 
    }
     
    var keyLatch = false;
    var paused = false;

    var t_ = 0;
    var t;
    var dt = 0;
    var current_sample = null;
    var vizspeed = 3;
    

    function updateRef(){
        if(current_sample === null && pendingData.length > 0){
            // Pop sample from front of queue
            current_sample = pendingData.splice(0,1)[0];
        }

        t = performance.now()/1000.0;
        if (t - t_ > dt/vizspeed){
            ref.x   = current_sample.state[0];
            ref.y   = current_sample.state[1];
            ref.psi = current_sample.state[2];
            ref.u   = current_sample.state[3];
            ref.v   = current_sample.state[4];
            ref.r   = current_sample.state[5];

            t_ = t;
            dt = pendingData[0].t - current_sample.t;
            current_sample = null;
        }
    }

    function updateState(){
        vizstate = ref;
    }

    function updateBoat(){
        boat.x = vizstate.x;
        boat.y = vizstate.y;
        boat.rotation = vizstate.psi - Math.PI/2
        //boat.setVelocityX( vizstate.v );
        //boat.setVelocityY( -vizstate.u );
    }

    function update ()
    {
        updateRef();
        updateState();
        updateBoat();
        
        // boat.setVelocityX( state.surge*Math.sin(boat.rotation) );
        // boat.setVelocityY( -state.surge*Math.cos(boat.rotation) );
        
        // if (cursors.space.isDown){
        //     if (!keyLatch){
        //         keyLatch = true;
        //         if (paused){
        //             boat.x = 512;
        //             boat.y = 512;
        //             state.heading = 0;
        //             this.physics.resume();
        //             paused = false;
        //         } else {
        //             this.physics.pause();
        //             paused = true;
        //         }      
        //     }
        // } else 
        // if (cursors.left.isDown){
        //     if (!keyLatch){
        //         keyLatch = true;
        //         state.heading -= 5;
        //         console.log(state)
        //     }
        // } else if (cursors.right.isDown){
        //     if (!keyLatch){
        //         keyLatch = true;
        //         state.heading += 5;
        //         console.log(state)
        //     }
        // } else if (cursors.up.isDown){
        //     if (!keyLatch){
        //         keyLatch = true;
        //         state.surge += 15;
        //         console.log(state)
        //     }
        // } else if (cursors.down.isDown){
        //     if (!keyLatch){
        //         keyLatch = true;
        //         state.surge -= 15;
        //         console.log(state)
        //     }
        // } else {
        //     keyLatch = false;
        // }
    }

</script>

</body>
</html>