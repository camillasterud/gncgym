<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Making your first Phaser 3 Game - Part 2</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.13.0/dist/phaser.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
    <script type="text/javascript" src="static/scripts/Arrow.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
    namespace = '';

    var socket = io.connect(location.protocol + '//' + document.domain + ':' + location.port + namespace);
    var pendingData = []    

    // How the data is received
    socket.on('sim_state', function(msg) {
        // Make sure that the datasource has the correct values
        msg.data.forEach(point => {
            pendingData.push(point);
        });
    });

    

    var w = 1024;
    var h = 1024;
    var scale = 1;
    
    var config = {
        type: Phaser.AUTO,
        width: w,
        height: h,
        backgroundColor: '#0b486b',
        physics: {
            default: 'arcade',
            arcade: {
                debug: false
            }
        },
        scene: {
            preload: preload,
            create: create,
            update: update
        }
    };

    var game = new Phaser.Game(config);
    var seatile;
    var seasprites = [];
    
    // Graphics obj containing all the arros that represent the current
    var currentArrowGraphics;
    var currentArrows = [];
    
    // Contains the graphics object that handles the boat trail
    var pointGraphics;
    var points = [];
    var lastPoint = null;

    // Contains all graphics objects related to the boat, 
    // such as the arrows for the vizReference
    var boatGraphics;
    var ref_arrow;

    var vizState = {
        x: 0,
        y: 0,
        psi: 0,
        u: 0,
        v: 0,
        r: 0
    };

    var vizRef = {
        x: 0,
        y: 0,
        psi: 0,
        u: 0,
        v: 0,
        r: 0
    };

    var boatRef = {
        u: 0,
        psi: 0
    };



    function preload ()
    {
        this.backgroundColor = '#0072bc';
        this.load.spritesheet('seatile', 'static/assets/sea-sprite-sheet.png', { frameWidth: 128, frameHeight: 128 });
        this.load.spritesheet('seasprite', 'static/assets/sea-sprite-sheet.png', { frameWidth: 128, frameHeight: 128 });
        this.load.image('boat', 'static/assets/boat.png')
        // this.load.spritesheet('boat', 'static/assets/boat.png', { frameWidth: 478, frameHeight: 748 })
    }

    function create ()
    {    

        currentArrowGraphics = this.add.graphics({ 
            lineStyle: { width: 2, color: 0x111111 }, 
            fillStyle: { color: 0x111111 }
        });

        let n = 20;
        for (var i = -2 ; i<n+2 ; i++){
            for (var j = -10 ; j < n+10 ; j++){
                var pos = {x: (i+0.5)*w/n, y: (j+0.5)*h/n};
                var arr = new Arrow(currentArrowGraphics, pos, 0, 20);
                currentArrows.push(arr);
            }
        }

        pointGraphics = this.add.graphics({ lineStyle: { width: 2, color: 0x994466 } });
        
        boat = this.add.sprite(100, 150, 'boat')
        boatGraphics = this.add.graphics({ 
            lineStyle: { width: 2, color: 0xaa2200 },
            fillStyle: { color: 0xaa2200 }
        } );
        ref_arrow = new Arrow(boatGraphics, {x: boat.x, y: boat.y}, 0, 40);

        // boat = this.physics.add.sprite(w/2, h/2, 100, 150,'boat');

        this.cameras.main.startFollow(boat, true,  0.05, 0.05); 
    }

    var t_ = 0;
    var t;
    var dt = 0;
    var current_sample = null;
    var vizspeed = 1;
    

    function updateVizRef(){
        if(current_sample === null && pendingData.length > 0){
            // Pop sample from front of queue
            current_sample = pendingData.splice(0,1)[0];
        }

        t = performance.now()/1000.0;
        if (t - t_ > dt/vizspeed){
            vizRef.x    = current_sample.state[0];
            vizRef.y    = current_sample.state[1];
            vizRef.psi  = current_sample.state[2];
            vizRef.u    = current_sample.state[3];
            vizRef.v    = current_sample.state[4];
            vizRef.r    = current_sample.state[5];

            boatRef.u   = current_sample.ref[0];
            boatRef.psi = current_sample.ref[1];

            t_ = t;
            dt = pendingData[0].t - current_sample.t;
            current_sample = null;
        }
    }

    function updateState(){
        // Include some dynamics here for smoother animation
        vizState = vizRef;

    }

    function updateBoat(){
        // update the displayed boat state after the dynamics have been updated 
        boat.x = vizState.x;
        boat.y = -vizState.y;
        boat.rotation = -vizState.psi + Math.PI/2;

        // update the direction and position of the reference arrows
        ref_arrow.setAngle( -boatRef.psi)
        ref_arrow.moveBaseTo(boat.x, boat.y);
    }

    function trail(){
        if ( (lastPoint === null) || (50 < ((boat.x - lastPoint.x)**2 + (boat.y - lastPoint.y)**2))){
            lastPoint = new Phaser.Geom.Point(boat.x, boat.y);
            //points.push(lastPoint);
            pointGraphics.fillPointShape(lastPoint, 5)
        }
    }

    function update ()
    {   
        // TODO only update things using events, maybe a timer func to schedule vizState updates?
        // The rest should just be based on events coming form the data source.

        // TODO Only clear graphics when there's an update
        
        updateVizRef();
        updateState();
        updateBoat();

        currentArrowGraphics.clear();
        boatGraphics.clear()

        ref_arrow.stroke();
        currentArrows.forEach(arrow => {
            arrow.stroke();
        });

        trail();
    }

</script>

</body>
</html>